If a help_prev() unlocked a->n, no del(a) can write to pn until it locks
a->n anew. "Anew" means after the unlock. "Writing" is a RMW operation.

Suppose a del(a) is committed to making a pn write and hasn't locked a->n
anew.

Then it must have locked a->n before help_prev() read a->n, since
help_prev().

help_prev() reads a->n, then hp := a->p and hpn := a->p->n, then locks
a->n. So it must have made these reads after del(a) locked a->n.

del(a) also read dp := a->p and dpn := a->p->n before locking a->n, and
thus before help_prev()'s reads.

If dp == hp, del(a) will fail its pn write because:
    del(a) must have seen dp->n unlocked, but help_prev() later saw dp->n
    locked. No subsequent write could restore dp->n == dpn.
    
If dp != hp, del(a) will fail because:
        

Since help_prev found pnh locked

So if help_prev() unlocks a->n and then writes to a->n, no del(a) can
succeed until it reads or tries to lock a->n and finds it modified.
